/* 
 * -----------------------------------------------------------------------------
 * Resource: https://www.oracletutorial.com/oracle-view/oracle-updatable-view/#:~:text=A%20view%20is%20updatable%20if,statement%20against%20the%20underlying%20table.
 * Overview: In this tutorial, you have learned about the Oracle updatable view 
 * and how to update underlying base tables through it.
 * -----------------------------------------------------------------------------
 * Oracle Updatable View
 * -----------------------------------------------------------------------------
 * Summary: in this tutorial, you will learn about Oracle updatable view and how 
 * to insert or update data in the base tables through a view.
 *
 * A view behaves like a table because you can query data from it. However, you 
 * cannot always manipulate data via views. 
 * 
 * A view is updatable if the statement against the view can be translated into 
 * the corresponding statement against the underlying table.
 * 
 * Let’s consider the following database tables:
    -----------              -----------
   |   CARS    |            |   BRANDS  |
   |-----------|            |-----------|
   |CAR_ID     | n ------ 1 |BRAND_ID   |
   |CAR_NAME   |            |BRAND_NAME |
   |BRAND_ID   |            -----------
    -----------
 * In database diagram, a car belongs to one brand while a brand has one or many 
 * cars. The relationship between brand and car is a one-to-many.
 *
 * The following SQL statements create the cars and brands tables; and also 
 * insert sample data into these tables. 
 * ----------------------------------------------------------------------------- 
 */
DROP TABLE saimk.updatable_views_cars;
DROP TABLE saimk.updatable_views_brands;
 
--brands table
CREATE TABLE saimk.updatable_views_brands(
	brand_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
	brand_name VARCHAR2(50) NOT NULL,
	PRIMARY KEY(brand_id)
)
;
--
--cars table
DROP TABLE saimk.updatable_views_cars;

CREATE TABLE saimk.updatable_views_cars (
	car_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
	car_name VARCHAR2(255) NOT NULL,
	brand_id NUMBER NOT NULL,
	PRIMARY KEY(car_id),
	FOREIGN KEY(brand_id) 
	REFERENCES saimk.updatable_views_brands(brand_id) ON DELETE CASCADE
)
;
/*
 * Populate brands table
 */
INSERT INTO saimk.updatable_views_brands(brand_name) VALUES('Audi');

INSERT INTO saimk.updatable_views_brands(brand_name) VALUES('BMW');

INSERT INTO saimk.updatable_views_brands(brand_name) VALUES('Ford');

INSERT INTO saimk.updatable_views_brands(brand_name) VALUES('Honda');

INSERT INTO saimk.updatable_views_brands(brand_name) VALUES('Toyota');
/*
 * Populate cars table
 */
INSERT INTO saimk.updatable_views_cars (car_name,brand_id) VALUES('Audi R8 Coupe',1);

INSERT INTO saimk.updatable_views_cars (car_name,brand_id) VALUES('Audi Q2', 1);

INSERT INTO saimk.updatable_views_cars (car_name,brand_id) VALUES('Audi S1', 1);

INSERT INTO saimk.updatable_views_cars (car_name,brand_id) VALUES('BMW 2-serie Cabrio', 2);

INSERT INTO saimk.updatable_views_cars (car_name,brand_id) VALUES('BMW i8', 2);

INSERT INTO saimk.updatable_views_cars (car_name,brand_id) VALUES('Ford Edge', 3);

INSERT INTO saimk.updatable_views_cars (car_name,brand_id) VALUES('Ford Mustang Fastback', 3);

INSERT INTO saimk.updatable_views_cars (car_name,brand_id) VALUES('Honda S2000', 4);

INSERT INTO saimk.updatable_views_cars (car_name,brand_id) VALUES('Honda Legend', 4);

INSERT INTO saimk.updatable_views_cars (car_name,brand_id) VALUES('Toyota GT86', 5);

INSERT INTO saimk.updatable_views_cars (car_name,brand_id) VALUES('Toyota C-HR', 5);
--
COMMIT;
--
/*
 * List brands and cars tables
 */
SELECT t.* FROM saimk.updatable_views_brands t; 

SELECT t.* FROM saimk.updatable_views_cars t;  
/*----------------------------------------------------------------------------*/       
/*   
 * -----------------------------------------------------------------------------
 * EXAMPLE 1: Oracle updatable view example
 * -----------------------------------------------------------------------------
 * The following statement creates a new view named cars_master:
 * ----------------------------------------------------------------------------- 
 */
CREATE OR REPLACE VIEW saimk.updatable_views_cars_master_v1 AS 
SELECT t.car_id,
       t.car_name
FROM saimk.updatable_views_cars t
;

SELECT v.* FROM saimk.updatable_views_cars_master_v1 v; 

/*
 * It’s possible to delete a row from the cars table via the cars_master view, 
 * for example:
 */
DELETE
FROM saimk.updatable_views_cars_master_v1 v
WHERE v.car_id = 1
;
--
ROLLBACK;
--
/*    
 * And you can update any column values exposed to the cars_master view:
 */
UPDATE saimk.updatable_views_cars_master_v1 v
SET v.car_name = 'Audi RS7 Sportback'
WHERE v.car_id = 2
;
--
ROLLBACK;
--   
/*    
 * We could do delete and update data from the cars table via cars_master view 
 * because Oracle can translate the DELETE and UPDATE statements to the 
 * corresponding statements and execute them against the cars table.
 *
 * However, insert a new row into the cars table via the cars_master view is not 
 * possible. Because the cars table has a not null column( brand_id) without a 
 * default value.
 *
 * If we try to insert a row by the below statement we get thıs error:
 * SQL Error: ORA-00947: not enough values
 */
INSERT INTO saimk.updatable_views_cars_master_v1 VALUES('Audi S1 Sportback');
--
ROLLBACK;
--
/*----------------------------------------------------------------------------*/
/*
 * -----------------------------------------------------------------------------
 * EXAMPLE 2: Oracle updatable join view example
 * -----------------------------------------------------------------------------
 * Let’s create a join view named all_cars based on the cars and brands tables.
 * ----------------------------------------------------------------------------- 
 */
CREATE OR REPLACE VIEW saimk.updatable_views_all_cars_v1 AS 
SELECT
    c.car_id,
    c.car_name,
    c.brand_id,
    b.brand_name
FROM saimk.updatable_views_cars c
INNER JOIN updatable_views_brands b 
      ON b.brand_id = c.brand_id
; 
/*
 * The following statement inserts a new row into the cars table via the 
 * all_cars view:
 */
INSERT INTO saimk.updatable_views_all_cars_v1(car_name, brand_id) VALUES('Audi A5 Cabriolet', 1);
--
ROLLBACK;
--
/*
 * A new row has been inserted into the cars table. This INSERT statement works 
 * because Oracle can decompose it to an INSERT statement against the cars 
 * table.
 */
/* 
 * The following statement deletes all Honda cars from the cars table via the 
 * all_cars view:
 */
DELETE
FROM saimk.updatable_views_all_cars_v1 v
WHERE v.brand_name = 'Honda'
;
--
ROLLBACK;
--
/*----------------------------------------------------------------------------*/
/*
 * Oracle has some rules and restrictions that apply to updatable join views. 
 * One of them is the concept of key-preserved tables.
 * 
 * A key-preserved table is a base table with a one-to-one row relationship with 
 * the rows in the view, via either the primary key or a unique key. In the 
 * example above, the cars table is a key-preserved table.
 *  
 * Here are some examples of updatable join view restrictions:
 *
 * 1) The SQL statement e.g., INSERT, UPDATE, and DELETE, is only allowed to  
 * modify data from a single base table.
 *
 * 2) For an INSERT statement, all columns listed in the INTO clause must belong 
 * to a key-preserved table.
 *
 * 3) For an UPDATE statement, all columns in the SET clause must belong to a 
 * key-preserved table.
 * 
 * 4) For a DELETE statement, if the join results in more than one key-preserved 
 * table, the Oracle deletes from the first table in the FROM clause.
 * 
 * 5) Besides these restrictions, Oracle also requires that the defining-query 
 * does not contain any of the following elements:
 *
 * Aggregate functions e.g., AVG, COUNT, MAX, MIN, and SUM.
 * DISTINCT operator.
 * GROUP BY clause.
 * HAVING clause.
 * Set operators e.g., UNION, UNION ALL, INTERSECT, and MINUS.
 * START WITH or CONNECT BY clause
 * ROWNUM pseudo-column
 */
/*----------------------------------------------------------------------------*/
/*
 * -----------------------------------------------------------------------------
 * Find updatable columns of a join view
 * -----------------------------------------------------------------------------
 * To find which column can be updated, inserted, or deleted, you use the 
 * user_updatable_columns view. The following example shows which column of the 
 * all_cars view is updatable, insertable, and deletable:
 * ----------------------------------------------------------------------------- 
 */
SELECT t.*
FROM USER_UPDATABLE_COLUMNS t
WHERE t.TABLE_NAME IN('UPDATABLE_VIEWS_ALL_CARS_V1', 'UPDATABLE_VIEWS_CARS_MASTER_V1')
ORDER BY t.TABLE_NAME
;
/*----------------------------------------------------------------------------*/